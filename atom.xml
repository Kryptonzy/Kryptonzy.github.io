<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-17T02:17:39.186Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java初步</title>
    <link href="http://example.com/2024/06/16/JAVA%E5%88%9D%E6%AD%A5/"/>
    <id>http://example.com/2024/06/16/JAVA%E5%88%9D%E6%AD%A5/</id>
    <published>2024-06-16T11:30:33.370Z</published>
    <updated>2024-06-17T02:17:39.186Z</updated>
    
    <content type="html"><![CDATA[<p>当然可以，我可以解释这些文件及其之间的关系。</p><h3 id="1-controller-包"><a href="#1-controller-包" class="headerlink" title="1. controller 包"></a>1. <code>controller</code> 包</h3><ul><li><strong><code>AdminController</code></strong> 和 <strong><code>UserController</code></strong>:<br>这些是控制器类，负责处理HTTP请求并返回响应。<code>AdminController</code>通常处理管理员相关的请求，而 <code>UserController</code>处理用户相关的请求。控制器类使用注解（如 <code>@GetMapping</code>, <code>@PostMapping</code>等）来映射请求URL。</li></ul><h3 id="2-entity-包"><a href="#2-entity-包" class="headerlink" title="2. entity 包"></a>2. <code>entity</code> 包</h3><ul><li><strong><code>User</code></strong>, <strong><code>Order</code></strong>, <strong><code>Evaluation</code></strong>, <strong><code>Maintenance</code></strong>:<br>这些是实体类，代表数据库中的表结构。每个实体类对应数据库中的一个表，类中的属性对应表中的列。这些类通常带有getter和setter方法，用于访问和修改属性。</li></ul><h3 id="3-mapper-包"><a href="#3-mapper-包" class="headerlink" title="3. mapper 包"></a>3. <code>mapper</code> 包</h3><ul><li><strong><code>AdminMapper</code></strong> 和 <strong><code>UserMapper</code></strong>:<br>这些是MyBatis的Mapper接口，负责定义数据库操作的方法。这些接口通过注解或XML配置文件中的SQL语句与数据库交互。<code>UserMapper</code>负责用户相关的数据库操作，而 <code>AdminMapper</code>负责管理员相关的数据库操作。</li></ul><h3 id="4-service-包"><a href="#4-service-包" class="headerlink" title="4. service 包"></a>4. <code>service</code> 包</h3><ul><li><strong><code>AdminService</code></strong> 和 <strong><code>UserService</code></strong>:<br>这些是服务类，包含业务逻辑。<code>UserService</code>负责用户相关的业务逻辑，而 <code>AdminService</code>负责管理员相关的业务逻辑。服务类通过自动装配（如 <code>@Autowired</code>）使用Mapper接口或Repository接口与数据库交互。</li></ul><h3 id="5-Demo2Application-类"><a href="#5-Demo2Application-类" class="headerlink" title="5. Demo2Application 类"></a>5. <code>Demo2Application</code> 类</h3><p>这是Spring Boot应用的启动类，带有 <code>@SpringBootApplication</code>注解。它包含 <code>main</code>方法，用于启动Spring Boot应用。</p><h3 id="文件关系总结"><a href="#文件关系总结" class="headerlink" title="文件关系总结"></a>文件关系总结</h3><ol><li><p><strong>控制器 (Controller)</strong>：</p><ul><li>接收HTTP请求。</li><li>调用服务类中的方法处理业务逻辑。</li><li>返回视图或响应数据。</li></ul></li><li><p><strong>服务 (Service)</strong>：</p><ul><li>包含业务逻辑。</li><li>调用Mapper或Repository接口与数据库交互。</li></ul></li><li><p><strong>实体 (Entity)</strong>：</p><ul><li>代表数据库表结构。</li><li>在服务和控制器之间传递数据。</li></ul></li><li><p><strong>Mapper</strong>：</p><ul><li>负责数据库操作。</li><li>Mapper接口使用MyBatis框架。</li></ul></li></ol><p>这些组件共同协作，构成了一个典型的Spring Boot应用程序，处理从接收请求到返回响应的整个流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当然可以，我可以解释这些文件及其之间的关系。&lt;/p&gt;
&lt;h3 id=&quot;1-controller-包&quot;&gt;&lt;a href=&quot;#1-controller-包&quot; class=&quot;headerlink&quot; title=&quot;1. controller 包&quot;&gt;&lt;/a&gt;1. &lt;code&gt;cont</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>富文本格式</title>
    <link href="http://example.com/2024/06/14/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/"/>
    <id>http://example.com/2024/06/14/%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/</id>
    <published>2024-06-14T08:16:54.887Z</published>
    <updated>2024-06-14T11:27:08.167Z</updated>
    
    <content type="html"><![CDATA[<p><strong>富文本格式（Rich Text Format）即RTF格式，又称多文本格式，是由</strong><a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767?fromModule=lemma_inlink">微软</a>公司开发的<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0/8558902?fromModule=lemma_inlink">跨平台</a>文档格式。大多数的<a href="https://baike.baidu.com/item/%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6/4719058?fromModule=lemma_inlink">文字处理软件</a>都能读取和保存RTF文档。它是一种方便于不同的设备、系统查看的文本和图形文档格式。它允许文本包含多种样式和格式，如加粗、斜体、下划线、颜色、字体大小、列表、链接、图片等。这种格式使得文本内容更加丰富和具有吸引力，同时便于阅读和理解。</p><p>富文本格式通常使用HTML（HyperText Markup Language）或者富文本编辑器（如TinyMCE、CKEditor等）来实现。HTML是网页的标准标记语言，它使用标签来定义文本的格式和样式。例如：</p><ul><li><code>&lt;b&gt;</code> 标签用于加粗文本。</li><li><code>&lt;i&gt;</code> 标签用于斜体文本。</li><li><code>&lt;u&gt;</code> 标签用于下划线文本。</li><li><code>&lt;a href=&quot;URL&quot;&gt;</code> 标签用于创建超链接。</li><li><code>&lt;img src=&quot;image_url&quot;&gt;</code> 标签用于插入图片。</li></ul><p>富文本编辑器提供了一个用户友好的界面，允许用户通过拖放、点击按钮或使用快捷键来应用各种格式和样式，而无需直接编写HTML代码。</p><p>富文本格式的优势包括：</p><ol><li><strong>增强的可读性</strong>：通过不同的字体、大小和颜色，可以突出显示重要信息。</li><li><strong>视觉吸引力</strong>：丰富的格式和样式可以吸引读者的注意力。</li><li><strong>结构化内容</strong>：列表、标题和段落等可以清晰地组织内容。</li><li><strong>交互性</strong>：可以包含链接、按钮和其他交互元素。</li></ol><p>然而，富文本格式也有其局限性，比如在不同的浏览器或设备上可能会显示不一致，以及在不支持富文本的平台上可能无法正确显示。</p><p>在编写富文本时，重要的是要确保内容的可访问性，比如为图片提供替代文本（alt text），以及确保内容在没有样式的情况下仍然易于阅读。</p><p>与富文本格式相关的一些概念包括：</p><ol><li><strong>HTML (HyperText Markup Language)</strong> ：一种用于创建网页的标准标记语言，它允许定义文本的结构和样式。</li><li><strong>CSS (Cascading Style Sheets)</strong> ：用于控制网页的布局和外观的样式表语言，可以与HTML结合使用来增强富文本的视觉效果。</li><li><strong>JavaScript</strong> ：一种脚本语言，用于创建动态的网页元素，可以与HTML和CSS一起使用，为富文本添加交互性。</li><li><strong>DOM (Document Object Model)</strong> ：一种编程接口，用于HTML和XML文档。它将文档呈现为一个树形结构，使得JavaScript可以动态地访问和修改页面内容。</li><li><strong>WYSIWYG (What You See Is What You Get)</strong> ：所见即所得编辑器，允许用户在编辑时看到最终的排版效果，常用于富文本编辑器。</li><li><strong>Markdown</strong> ：一种轻量级标记语言，用于格式化文本，它使用简单的标记符号来表示不同的格式，但不如富文本格式那样丰富。</li><li><strong>Rich Text Editor</strong> ：富文本编辑器，是一种软件组件，允许用户以所见即所得的方式编辑富文本内容。</li><li><strong>ContentEditable</strong> ：HTML中的一个属性，当设置为true时，可以使网页元素成为可编辑的富文本区域。</li><li><strong>ARIA (Accessible Rich Internet Applications)</strong> ：一种用于提高Web应用可访问性的技术，通过提供额外的语义信息来帮助辅助技术理解富文本内容。</li><li><strong>Semantic HTML</strong> ：语义化HTML，使用具有明确意义的HTML标签来组织内容，有助于搜索引擎优化和辅助技术的理解。</li><li><strong>Responsive Web Design</strong> ：响应式网页设计，确保网页在不同设备和屏幕尺寸上都能正确显示，富文本格式在响应式设计中也应保持一致性。</li><li><strong>Cross-Browser Compatibility</strong> ：跨浏览器兼容性，确保网页在不同的浏览器上都能正确显示和工作，包括富文本格式。</li><li><strong>Web Accessibility</strong> ：网页可访问性，确保所有用户，包括残障人士，都能访问和使用网页内容，富文本格式应遵循可访问性指南。</li><li><strong>Text-to-Speech (TTS)</strong> ：文本到语音技术，可以将文本内容转换为语音，对于富文本格式，TTS技术需要能够正确解析和朗读文本格式。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;富文本格式（Rich Text Format）即RTF格式，又称多文本格式，是由&lt;/strong&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF/124767?fromModule=lemma</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深度学习总结</title>
    <link href="http://example.com/2024/06/14/%E7%82%BC%E4%B8%B9/"/>
    <id>http://example.com/2024/06/14/%E7%82%BC%E4%B8%B9/</id>
    <published>2024-06-14T07:36:47.210Z</published>
    <updated>2024-06-14T11:26:59.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深度学习项目流程"><a href="#深度学习项目流程" class="headerlink" title="深度学习项目流程"></a>深度学习项目流程</h2><p>完成一个深度学习项目通常包括以下几个步骤，每个步骤都需要仔细规划和执行：</p><h3 id="1-项目定义与目标设定"><a href="#1-项目定义与目标设定" class="headerlink" title="1. 项目定义与目标设定"></a>1. <strong>项目定义与目标设定</strong></h3><ul><li><strong>确定问题</strong>：明确要解决的具体问题或任务（例如图像分类、对象检测、自然语言处理等）。</li><li><strong>设定目标</strong>：定义项目的具体目标和成功标准（例如达到某个准确率、缩短处理时间等）。</li></ul><h3 id="2-数据收集与准备"><a href="#2-数据收集与准备" class="headerlink" title="2. 数据收集与准备"></a>2. <strong>数据收集与准备</strong></h3><ul><li><strong>数据收集</strong>：从公开数据集、传感器、日志文件等渠道获取相关数据。</li><li><strong>数据清洗</strong>：处理缺失数据、异常值、重复数据等，确保数据质量。</li><li><strong>数据标注</strong>：根据项目需求对数据进行标注（例如图像的分类标签、对象的边界框等）。</li><li><strong>数据分割</strong>：将数据集分为训练集、验证集和测试集，通常按照8:1:1的比例进行分割。</li></ul><h3 id="3-探索性数据分析-EDA"><a href="#3-探索性数据分析-EDA" class="headerlink" title="3. 探索性数据分析 (EDA)"></a>3. <strong>探索性数据分析 (EDA)</strong></h3><ul><li><strong>数据可视化</strong>：使用图表和统计分析工具了解数据分布和特征。</li><li><strong>特征工程</strong>：提取、选择和创建新的特征，以提高模型的性能。</li></ul><h3 id="4-选择和设计模型"><a href="#4-选择和设计模型" class="headerlink" title="4. 选择和设计模型"></a>4. <strong>选择和设计模型</strong></h3><ul><li><strong>选择算法</strong>：根据任务性质选择合适的深度学习算法（例如卷积神经网络CNN、循环神经网络RNN、Transformer等）。</li><li><strong>设计模型架构</strong>：设计模型的具体结构，包括层数、每层的神经元数、激活函数等。</li></ul><h3 id="5-模型训练"><a href="#5-模型训练" class="headerlink" title="5. 模型训练"></a>5. <strong>模型训练</strong></h3><ul><li><strong>定义损失函数和优化器</strong>：选择合适的损失函数（例如交叉熵损失、均方误差等）和优化器（例如SGD、Adam等）。</li><li><strong>超参数调整</strong>：通过网格搜索或随机搜索等方法调整模型的超参数（例如学习率、批次大小等）。</li><li><strong>模型训练</strong>：使用训练数据进行模型训练，并在验证集上评估模型性能，调整模型参数。</li></ul><h3 id="6-模型评估与调优"><a href="#6-模型评估与调优" class="headerlink" title="6. 模型评估与调优"></a>6. <strong>模型评估与调优</strong></h3><ul><li><strong>性能评估</strong>：使用测试集评估模型的最终性能（例如准确率、召回率、F1分数等）。</li><li><strong>模型调优</strong>：根据评估结果进一步调优模型，可能需要重新进行特征工程、调整模型架构或超参数。</li></ul><h3 id="7-模型部署"><a href="#7-模型部署" class="headerlink" title="7. 模型部署"></a>7. <strong>模型部署</strong></h3><ul><li><strong>选择部署环境</strong>：确定模型的部署环境（例如云端、边缘设备、移动设备等）。</li><li><strong>模型导出</strong>：将模型导出为适合部署的格式（例如ONNX、TensorFlow Lite等）。</li><li><strong>部署实施</strong>：将模型部署到实际环境中，并进行集成测试。</li></ul><h3 id="8-模型监控与维护"><a href="#8-模型监控与维护" class="headerlink" title="8. 模型监控与维护"></a>8. <strong>模型监控与维护</strong></h3><ul><li><strong>性能监控</strong>：持续监控模型的性能，确保模型在实际应用中的表现。</li><li><strong>模型更新</strong>：根据实际需求定期更新模型，处理数据漂移、模型老化等问题。</li></ul><h3 id="9-项目总结与文档编写"><a href="#9-项目总结与文档编写" class="headerlink" title="9. 项目总结与文档编写"></a>9. <strong>项目总结与文档编写</strong></h3><ul><li><strong>总结报告</strong>：撰写项目总结报告，包含问题定义、数据处理、模型设计、训练过程、性能评估、部署和维护等内容。</li><li><strong>文档编写</strong>：撰写详细的技术文档，便于后续的维护和二次开发。</li></ul><p>每个步骤都可能需要反复迭代，根据具体项目的需求和挑战不断调整和优化。</p><h2 id="推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分："><a href="#推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分：" class="headerlink" title="推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分："></a>推理（Inference）和测试（Testing）分别属于深度学习项目流程中的不同部分：</h2><h3 id="流程中的推理（Inference）"><a href="#流程中的推理（Inference）" class="headerlink" title="流程中的推理（Inference）"></a>流程中的推理（Inference）</h3><p>推理属于 <strong>模型部署</strong> 这一部分。推理是指将训练好的模型应用于实际场景，对新数据进行预测和分类的过程。推理通常发生在模型已经通过测试和验证，并正式上线部署之后。</p><p>在项目流程中，推理的具体步骤包括：</p><ol><li><strong>选择部署环境</strong> ：确定模型的部署环境（如云端、边缘设备、移动设备等）。</li><li><strong>模型导出</strong> ：将模型导出为适合部署的格式（如 ONNX、TensorFlow Lite 等）。</li><li><strong>部署实施</strong> ：将模型部署到实际环境中，并进行集成测试。</li><li><strong>实时预测</strong> ：使用模型对实际应用中的新数据进行预测。</li></ol><h3 id="流程中的测试（Testing）"><a href="#流程中的测试（Testing）" class="headerlink" title="流程中的测试（Testing）"></a>流程中的测试（Testing）</h3><p>测试属于 <strong>模型评估与调优</strong> 这一部分。测试是通过使用独立的测试数据集来评估模型性能的过程，以验证模型的泛化能力和准确性。测试通常在模型训练完成后进行，是评估和验证模型效果的关键步骤。</p><p>在项目流程中，测试的具体步骤包括：</p><ol><li><strong>性能评估</strong> ：使用测试集评估模型的最终性能（如准确率、召回率、F1 分数等）。</li><li><strong>指标计算</strong> ：计算各种性能指标，以分析和比较模型。</li><li><strong>模型调优</strong> ：根据评估结果进一步调优模型，可能需要重新进行特征工程、调整模型架构或超参数。</li><li><strong>模型选择</strong> ：根据测试结果选择最佳模型，准备进行部署。</li></ol><h2 id="如何改进模型的性能"><a href="#如何改进模型的性能" class="headerlink" title="如何改进模型的性能"></a>如何改进模型的性能</h2><h3 id="1-调整模型架构"><a href="#1-调整模型架构" class="headerlink" title="1. 调整模型架构"></a>1. 调整模型架构</h3><p>尝试增加或减少LSTM单元的数量，添加更多的LSTM层或其他类型的层（如GRU），以探索最适合你数据的模型架构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(LSTM(<span class="number">128</span>, return_sequences=<span class="literal">True</span>, input_shape=(time_steps, <span class="number">4</span>)))  <span class="comment"># 增加LSTM单元数量</span></span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(<span class="number">64</span>, return_sequences=<span class="literal">True</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(LSTM(<span class="number">32</span>))  <span class="comment"># 增加LSTM层</span></span><br><span class="line">model.add(Dropout(<span class="number">0.2</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="2-调整超参数"><a href="#2-调整超参数" class="headerlink" title="2. 调整超参数"></a>2. 调整超参数</h3><p>可以尝试调整学习率、batch size和dropout率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整学习率</span></span><br><span class="line">optimizer = Adam(learning_rate=<span class="number">0.001</span>)  <span class="comment"># 默认0.001，可以尝试更低或更高的学习率</span></span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=optimizer, loss=<span class="string">&#x27;mean_squared_error&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-增加训练轮数（epochs）"><a href="#3-增加训练轮数（epochs）" class="headerlink" title="3. 增加训练轮数（epochs）"></a>3. 增加训练轮数（epochs）</h3><p>虽然当前的训练轮数是50，你可以尝试增加训练轮数以确保模型充分训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history = model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">32</span>, validation_data=(X_test, y_test))  <span class="comment"># 增加epochs</span></span><br></pre></td></tr></table></figure><h3 id="4-使用早停法（Early-Stopping）"><a href="#4-使用早停法（Early-Stopping）" class="headerlink" title="4. 使用早停法（Early Stopping）"></a>4. 使用早停法（Early Stopping）</h3><p>早停法可以在验证损失不再下降时提前停止训练，防止过拟合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">early_stopping = EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">10</span>, restore_best_weights=<span class="literal">True</span>)</span><br><span class="line">history = model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">32</span>, validation_data=(X_test, y_test), callbacks=[early_stopping])</span><br></pre></td></tr></table></figure><h3 id="5-数据归一化"><a href="#5-数据归一化" class="headerlink" title="5. 数据归一化"></a>5. 数据归一化</h3><p>确保你的数据已经归一化，可以使用MinMaxScaler或StandardScaler进行数据标准化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">data_normalized = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure><h3 id="6-数据增强"><a href="#6-数据增强" class="headerlink" title="6. 数据增强"></a>6. 数据增强</h3><p>如果数据量较小，可以尝试进行数据增强（例如时间序列数据的滑动窗口法）。</p><h3 id="7-交叉验证"><a href="#7-交叉验证" class="headerlink" title="7. 交叉验证"></a>7. 交叉验证</h3><p>使用交叉验证来评估模型的泛化性能，确保模型在不同数据集上的表现一致。</p><h2 id="相关参数介绍"><a href="#相关参数介绍" class="headerlink" title="相关参数介绍"></a>相关参数介绍</h2><p><img src="image/炼丹/1718358412998.png" alt="1718358412998"></p><p>这张图片显示了在一个训练和验证过程中各项损失函数和评估指标的变化情况，共包含八个图表。以下是每个图表的具体信息：</p><ol><li><strong>train/box_loss</strong>：这是训练过程中框损失（box loss）的变化曲线。从图中可以看到，随着训练轮次的增加，框损失逐渐降低。</li><li><strong>train/cls_loss</strong>：这是训练过程中分类损失（classification loss）的变化曲线。从图中可以看到，分类损失在训练初期急剧下降，随后逐渐趋于平稳。</li><li><strong>train/dfl_loss</strong>：这是训练过程中分布聚焦损失（distribution focal loss）的变化曲线。图中显示该损失在逐渐下降。</li><li><strong>metrics/precision</strong>：这是训练过程中精度（precision）的变化曲线。图中显示精度在训练过程中有所波动，但整体趋势是上升的。</li><li><strong>metrics/recall</strong>：这是训练过程中召回率（recall）的变化曲线。图中显示召回率逐渐上升，表明模型在训练过程中对目标的识别能力不断增强。</li><li><strong>val/box_loss</strong>：这是验证过程中框损失的变化曲线。从图中可以看到，框损失在验证集上的表现有所波动，但总体趋势是下降的。</li><li><strong>val/cls_loss</strong>：这是验证过程中分类损失的变化曲线。图中显示分类损失在验证集上的表现也有所波动，但总体趋势是下降的。</li><li><strong>val/dfl_loss</strong>：这是验证过程中分布聚焦损失的变化曲线。图中显示该损失在验证集上逐渐下降。</li><li><strong>metrics/mAP_0.5</strong>：这是验证过程中平均精度（mean Average Precision，mAP）在IOU阈值为0.5时的变化曲线。图中显示mAP值逐渐上升，表明模型的检测精度在不断提高。</li><li><strong>metrics/mAP_0.5:0.95</strong>：这是验证过程中平均精度在不同IOU阈值（从0.5到0.95）下的变化曲线。图中显示该指标逐渐上升，表明模型在不同IOU阈值下的检测精度均有提高。</li></ol><p>这些图表展示了模型在训练和验证过程中不同损失函数和评估指标的变化情况，反映了模型训练效果的逐步提升。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深度学习项目流程&quot;&gt;&lt;a href=&quot;#深度学习项目流程&quot; class=&quot;headerlink&quot; title=&quot;深度学习项目流程&quot;&gt;&lt;/a&gt;深度学习项目流程&lt;/h2&gt;&lt;p&gt;完成一个深度学习项目通常包括以下几个步骤，每个步骤都需要仔细规划和执行：&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>STFT</title>
    <link href="http://example.com/2024/06/12/STFT/"/>
    <id>http://example.com/2024/06/12/STFT/</id>
    <published>2024-06-12T03:15:51.027Z</published>
    <updated>2024-06-18T05:52:19.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STFT介绍"><a href="#STFT介绍" class="headerlink" title="STFT介绍"></a>STFT介绍</h1><p>短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它通过在时间轴上应用移动窗口来分析信号的频率内容随时间的变化。STFT 是时频分析的基本工具之一，特别适用于分析非平稳信号（即频率成分随时间变化的信号）。</p><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><h4 id="连续时间信号的STFT"><a href="#连续时间信号的STFT" class="headerlink" title="连续时间信号的STFT"></a>连续时间信号的STFT</h4><p>设 $ x(t) $ 是一个连续时间信号，$ w(t) $ 是一个移动窗口函数（通常是一个短时窗，如汉宁窗或高斯窗）。STFT 的定义为：</p><script type="math/tex; mode=display">\text{STFT}_x(t, \omega) = \int_{-\infty}^{\infty} x(\tau) w(\tau - t) e^{-j \omega \tau} \, d\tau</script><p>其中：</p><ul><li>$ \text{STFT}_x(t, \omega)$是在时间 $ t $ 和频率 $ \omega $ 上的短时傅里叶变换。</li><li>$ x(\tau) $ 是原始信号。</li><li>$ w(\tau - t) $ 是移动窗口函数，中心位于 $ t $。</li><li>$ e^{-j \omega \tau} $ 是傅里叶变换的核函数。</li></ul><p>STFT 将信号在每个时间点 $ t $ 上截取一个窗函数 $ w(t) $，并对窗口内的信号进行傅里叶变换。通过移动窗函数的位置，可以得到不同时间点上的频谱，从而得到信号的时频表示。</p><h4 id="离散时间信号的STFT"><a href="#离散时间信号的STFT" class="headerlink" title="离散时间信号的STFT"></a>离散时间信号的STFT</h4><p>对于离散时间信号 $ x[n] $，其STFT定义为：</p><script type="math/tex; mode=display">\text{STFT}_x(m, \omega) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \omega n}</script><p>其中：</p><ul><li>$ x[n] $ 是离散时间信号。</li><li>$ w[n - m] $ 是移动窗口函数，中心位于 $ m $。</li><li>$ e^{-j \omega n} $ 是傅里叶变换的核函数。</li></ul><p>通常，离散时间STFT的频率参数 $ \omega $ 被离散化为 $ \omega = \frac{2\pi k}{N} $（其中 $ N $ 是FFT的长度），因此离散STFT可以表示为：</p><script type="math/tex; mode=display">\text{STFT}_x(m, k) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \frac{2\pi k}{N} n}</script><h3 id="STFT的步骤"><a href="#STFT的步骤" class="headerlink" title="STFT的步骤"></a>STFT的步骤</h3><ol><li><p><strong>窗口化</strong>：</p><ul><li>使用一个窗函数（如汉宁窗、高斯窗等）截取信号的一部分。窗口函数通常是一个短时窗，长度较短，可以移动。</li></ul></li><li><p><strong>移动窗口</strong>：</p><ul><li>将窗口函数在信号上移动，每次移动一个步长（通常称为 hop size），截取信号的不同部分。</li></ul></li><li><p><strong>傅里叶变换</strong>：</p><ul><li>对每个窗口内的信号进行傅里叶变换，计算出窗口内信号的频谱。</li></ul></li><li><p><strong>组合结果</strong>：</p><ul><li>将每个时间窗口的频谱组合在一起，形成信号的时频表示。</li></ul></li></ol><h3 id="STFT-的特性"><a href="#STFT-的特性" class="headerlink" title="STFT 的特性"></a>STFT 的特性</h3><ul><li><p><strong>时间和频率分辨率的权衡</strong>：</p><ul><li>窗口的长度决定了时间和频率分辨率之间的权衡。较短的窗口提供较高的时间分辨率，但频率分辨率较低；较长的窗口提供较高的频率分辨率，但时间分辨率较低。</li></ul></li><li><p><strong>非平稳信号的分析</strong>：</p><ul><li>STFT 特别适用于分析非平稳信号，可以捕捉信号频率成分随时间的变化。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用STFT进行时频分析的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例信号</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)  <span class="comment"># 时间向量</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算STFT</span></span><br><span class="line">f, t, Zxx = stft(signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制STFT结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.pcolormesh(t, f, np.<span class="built_in">abs</span>(Zxx), shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;STFT Magnitude&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Magnitude&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="nperseg、noverlap和-nfft参数的选择"><a href="#nperseg、noverlap和-nfft参数的选择" class="headerlink" title="nperseg、noverlap和 nfft参数的选择"></a><code>nperseg</code>、<code>noverlap</code>和 <code>nfft</code>参数的选择</h4><p>对于长度为512的EEG信号，选择 <code>nperseg</code>、<code>noverlap</code>和 <code>nfft</code>参数时需要考虑时间和频率分辨率之间的权衡。以下是一些选择这些参数的原则和示例：</p><ol><li><p><strong><code>nperseg</code> (每段的长度)</strong>:</p><ul><li>该参数决定了每个段的长度。通常，<code>nperseg</code>的选择应该小于信号长度，以便可以进行多段分析。</li><li>较小的 <code>nperseg</code>会提高时间分辨率，但会降低频率分辨率。反之，较大的 <code>nperseg</code>会提高频率分辨率，但会降低时间分辨率。</li></ul></li><li><p><strong><code>noverlap</code> (每段重叠的点数)</strong>:</p><ul><li>该参数决定了相邻段之间的重叠点数。通常设置为 <code>nperseg</code>的一半，以实现平滑的频谱估计。</li><li>较高的重叠率（即 <code>noverlap</code>较大）会增加计算量，但可以获得更平滑的频谱图。</li></ul></li><li><p><strong><code>nfft</code> (每段的FFT点数)</strong>:</p><ul><li>该参数决定了FFT的点数，通常设置为大于或等于 <code>nperseg</code>的值。</li><li>较大的 <code>nfft</code>会增加频率分辨率，但也会增加计算量。</li></ul></li></ol><p>对于长度为512的EEG信号，以下是一个推荐的参数选择：</p><ul><li><code>nperseg = 128</code>: 这是一个常用的值，提供了适中的时间和频率分辨率。</li><li><code>noverlap = 64</code>: 这是 <code>nperseg</code>的一半，提供了平滑的频谱估计。</li><li><code>nfft = 256</code>: 这是 <code>nperseg</code>的两倍，提供了较高的频率分辨率。</li></ul><p>以下是示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例EEG信号</span></span><br><span class="line">fs = <span class="number">256</span>  <span class="comment"># 采样率</span></span><br><span class="line">signal_length = <span class="number">512</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, signal_length / fs, signal_length, endpoint=<span class="literal">False</span>)  <span class="comment"># 时间向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个包含正弦波和噪声的示例信号</span></span><br><span class="line">f0 = <span class="number">10</span>  <span class="comment"># 信号频率</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * f0 * t) + <span class="number">0.5</span> * np.random.randn(<span class="built_in">len</span>(t))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置参数</span></span><br><span class="line">nperseg = <span class="number">128</span></span><br><span class="line">noverlap = <span class="number">64</span></span><br><span class="line">nfft = <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算瞬时频率</span></span><br><span class="line">frequencies, times, Sxx = spectrogram(signal, fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制时频图</span></span><br><span class="line">plt.pcolormesh(times, frequencies, <span class="number">10</span> * np.log10(Sxx), shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Spectrogram&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Intensity [dB]&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>生成示例EEG信号</strong>:</p><ul><li><code>fs</code> 是采样率，<code>signal_length</code> 是信号长度，<code>t</code> 是时间向量。</li><li>生成一个包含频率为 <code>f0</code>的正弦波和一些随机噪声的信号。</li></ul></li><li><p><strong>设置参数</strong>:</p><ul><li><code>nperseg = 128</code>: 每段长度为128。</li><li><code>noverlap = 64</code>: 每段之间有64个点的重叠。</li><li><code>nfft = 256</code>: 每段进行256点的FFT计算。</li></ul></li><li><p><strong>计算瞬时频率</strong>:</p><ul><li>使用 <code>scipy.signal.spectrogram</code> 函数计算瞬时频率。</li></ul></li><li><p><strong>绘制时频图</strong>:</p><ul><li>使用 <code>matplotlib</code> 绘制时频图。</li></ul></li></ol><p>通过这些参数设置，您可以获得一个平衡的时间和频率分辨率，适合分析长度为512的EEG信号。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>STFT 是一种通过在时间轴上应用移动窗口来分析信号频率内容随时间变化的方法。通过选择不同的窗口长度和步长，可以在时间和频率分辨率之间进行权衡，适用于分析非平稳信号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STFT介绍&quot;&gt;&lt;a href=&quot;#STFT介绍&quot; class=&quot;headerlink&quot; title=&quot;STFT介绍&quot;&gt;&lt;/a&gt;STFT介绍&lt;/h1&gt;&lt;p&gt;短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>瞬时频率</title>
    <link href="http://example.com/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/"/>
    <id>http://example.com/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/</id>
    <published>2024-06-11T16:37:38.887Z</published>
    <updated>2024-06-12T05:59:41.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种计算瞬时频率的方法"><a href="#两种计算瞬时频率的方法" class="headerlink" title="两种计算瞬时频率的方法"></a>两种计算瞬时频率的方法</h1><p>这两种方法在计算瞬时频率时有不同的原理和应用场景：</p><h3 id="Hilbert-变换方法"><a href="#Hilbert-变换方法" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Hilbert 变换方法通过计算信号的解析信号（analytic signal），并从中获取相位信息。然后，通过对相位进行微分得到瞬时频率。其数学表达式为：</p><script type="math/tex; mode=display">f_{\text{inst}}(t) = \frac{1}{2\pi} \frac{d\phi}{dt}</script><p>其中，$\phi$ 是解析信号的相位。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>直接且快速，适用于单分量信号（即信号的频率在任一时刻是单一的）。</li><li>对于噪声相对不敏感。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>对于多分量信号（即信号在同一时刻含有多个频率成分）效果较差，因为无法区分不同的频率成分。</li><li>对非平稳信号的瞬时频率变化可能不够准确。</li></ul></li></ol><h3 id="条件频谱矩方法（TFMoment）"><a href="#条件频谱矩方法（TFMoment）" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>条件频谱矩方法基于时间-频率分布（如谱图）的功率谱来计算瞬时频率。它计算在每个时刻的频谱重心，公式如下：</p><script type="math/tex; mode=display">f_{\text{inst}}(t) = \frac{\int_0^\infty f P(t, f) \, df}{\int_0^\infty P(t, f) \, df}</script><p>其中，$P(t, f)$ 是时间 $t$ 和频率 $f$ 下的功率谱。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>适用于多分量信号，能够区分和处理多个频率成分。</li><li>能够更准确地捕捉非平稳信号的瞬时频率变化。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>计算复杂度较高，需要计算时间-频率分布（如谱图）。</li><li>对于噪声敏感，可能需要对信号进行预处理以减少噪声的影响。</li></ul></li></ol><h3 id="如何选择方法"><a href="#如何选择方法" class="headerlink" title="如何选择方法"></a>如何选择方法</h3><ul><li><strong>单分量信号</strong>：如果您的信号在任一时刻只包含一个主要频率成分，并且信号相对平稳，Hilbert 变换方法可能更简单高效。</li><li><strong>多分量信号或非平稳信号</strong>：如果您的信号包含多个频率成分或是非平稳信号，条件频谱矩方法（TFMoment）更适合，因为它能够更准确地捕捉复杂信号的频率变化。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>这里是两个方法的实现示例，您可以根据您的具体需求选择合适的方法。</p><h4 id="Hilbert-变换方法-1"><a href="#Hilbert-变换方法-1" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> hilbert</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_hilbert</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t = np.arange(n_samples - <span class="number">1</span>) / fs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        analytic_signal = hilbert(signal[channel])</span><br><span class="line">        instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span><br><span class="line">        instantaneous_frequency = np.diff(instantaneous_phase) * fs / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        inst_freq.append(instantaneous_frequency)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_hilbert(x, fs)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (Hilbert)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="条件频谱矩方法（TFMoment）-1"><a href="#条件频谱矩方法（TFMoment）-1" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_tfmoment</span>(<span class="params">signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>, nfft=<span class="number">256</span></span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t_vals = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        f, t, Sxx = spectrogram(signal[channel], fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)</span><br><span class="line">        P_t_f = Sxx.T</span><br><span class="line">        numerator = np.<span class="built_in">sum</span>(f * P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        denominator = np.<span class="built_in">sum</span>(P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        inst_freq_channel = numerator / denominator</span><br><span class="line">        inst_freq.append(inst_freq_channel)</span><br><span class="line">        t_vals.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), np.array(t_vals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">nperseg = <span class="number">128</span></span><br><span class="line">noverlap = <span class="number">64</span></span><br><span class="line">nfft = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_tfmoment(x, fs, nperseg, noverlap, nfft)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (TFMoment)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过运行这些代码示例，您可以直观地看到不同方法的计算结果，并选择最适合您的应用场景的方法。如果您有进一步的需求或问题，请告诉我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;两种计算瞬时频率的方法&quot;&gt;&lt;a href=&quot;#两种计算瞬时频率的方法&quot; class=&quot;headerlink&quot; title=&quot;两种计算瞬时频率的方法&quot;&gt;&lt;/a&gt;两种计算瞬时频率的方法&lt;/h1&gt;&lt;p&gt;这两种方法在计算瞬时频率时有不同的原理和应用场景：&lt;/p&gt;
&lt;h3 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>世界是连续的还是离散的</title>
    <link href="http://example.com/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD/"/>
    <id>http://example.com/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD/</id>
    <published>2024-06-11T10:31:53.169Z</published>
    <updated>2024-06-12T06:00:13.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="世界是连续的还是离散的"><a href="#世界是连续的还是离散的" class="headerlink" title="世界是连续的还是离散的"></a>世界是连续的还是离散的</h1><p>“世界是连续的还是离散的”这一问题可以从不同的学科视角进行讨论，如物理学、哲学和计算机科学。每个领域的观点都可能有所不同。</p><h3 id="物理学视角"><a href="#物理学视角" class="headerlink" title="物理学视角"></a>物理学视角</h3><ol><li><strong>经典物理学</strong> ：</li></ol><ul><li>经典物理学（如牛顿力学、电磁学等）通常认为世界是连续的。例如，时间和空间被认为是连续的，物体可以在任何时间点和空间位置上运动。</li></ul><ol><li><strong>量子力学</strong> ：</li></ol><ul><li>量子力学提供了一种截然不同的观点。在微观尺度下，某些物理量是量子化的，即只能取离散的值。例如，电子的能级、光子的能量等都是离散的。这表明，在某些情况下，世界是离散的。</li><li>但量子力学中的波函数是连续的，它描述了粒子在空间中的概率分布。因此，量子力学同时包含连续和离散的特性。</li></ul><ol><li><strong>时空量子化</strong> ：</li></ol><ul><li>有些理论物理学家提出了时空量子化的概念，认为在极小尺度（如普朗克尺度）上，时空可能是离散的。这是一种仍在研究中的假设，尚未得到实验验证。</li></ul><h3 id="哲学视角"><a href="#哲学视角" class="headerlink" title="哲学视角"></a>哲学视角</h3><ol><li><strong>实在论</strong> ：</li></ol><ul><li>认为世界的本质是独立于我们的感知和测量的。对于这种观点，世界可以是连续的，也可以是离散的，这取决于其真实的物理特性。</li></ul><ol><li><strong>唯物主义</strong> ：</li></ol><ul><li>认为物质是世界的基本组成部分。这种观点通常倾向于认为世界是连续的，因为物质和能量的流动似乎是连续的。</li></ul><ol><li><strong>主观唯心主义</strong> ：</li></ol><ul><li>认为我们的感知决定了我们对世界的理解。对于这种观点，世界的连续性或离散性是由我们的感知和测量决定的，而不是世界本身的特性。</li></ul><h3 id="计算机科学视角"><a href="#计算机科学视角" class="headerlink" title="计算机科学视角"></a>计算机科学视角</h3><ol><li><strong>数字化世界</strong> ：</li></ol><ul><li>在计算机科学中，所有信息都是离散的。计算机处理离散的二进制数据，任何连续信号（如声音、图像）都必须经过采样和量化才能被计算机处理。</li></ul><ol><li><strong>模拟信号处理</strong> ：</li></ol><ul><li>虽然计算机处理的是离散信号，但它们可以模拟连续信号。这种模拟是通过高频采样和精确的计算来实现的。</li></ul><h3 id="综合视角"><a href="#综合视角" class="headerlink" title="综合视角"></a>综合视角</h3><ol><li><strong>多尺度视角</strong> ：</li></ol><ul><li>世界的连续性和离散性可能取决于观察的尺度。在宏观尺度上（如日常生活中的物体运动），世界看起来是连续的；而在微观尺度上（如原子和电子的行为），世界表现出离散性。</li></ul><ol><li><strong>测量和工具的限制</strong> ：</li></ol><ul><li>我们对世界的理解受到测量工具和方法的限制。高精度的测量工具可以揭示更微观的细节，而这些细节可能表现出离散性。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>世界是连续的还是离散的，取决于我们观察的尺度和视角。从宏观来看，世界似乎是连续的；从微观和量子力学的角度来看，世界表现出离散性。哲学上，世界的本质可能既包含连续性也包含离散性。这一问题并没有一个简单的答案，而是取决于具体的上下文和研究领域。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;世界是连续的还是离散的&quot;&gt;&lt;a href=&quot;#世界是连续的还是离散的&quot; class=&quot;headerlink&quot; title=&quot;世界是连续的还是离散的&quot;&gt;&lt;/a&gt;世界是连续的还是离散的&lt;/h1&gt;&lt;p&gt;“世界是连续的还是离散的”这一问题可以从不同的学科视角进行讨论，如物</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>谱熵</title>
    <link href="http://example.com/2024/06/11/%E8%B0%B1%E7%86%B5/"/>
    <id>http://example.com/2024/06/11/%E8%B0%B1%E7%86%B5/</id>
    <published>2024-06-11T09:23:23.869Z</published>
    <updated>2024-06-12T05:59:52.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>计算功率谱密度（Power Spectral Density, PSD）的常见算法有以下几种，每种算法的计算结果略有不同，适用于不同的场景。下面介绍几种常见的计算 PSD 的算法，并解释它们的输出形状。</p><h3 id="1-快速傅里叶变换-FFT"><a href="#1-快速傅里叶变换-FFT" class="headerlink" title="1. 快速傅里叶变换 (FFT)"></a>1. 快速傅里叶变换 (FFT)</h3><p>FFT 是最常用的一种方法，适用于分析信号的整体频率特性。计算结果为一维频谱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_fft</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(signal)</span><br><span class="line">    fft_values = fft(signal)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(fft_values) ** <span class="number">2</span> / N</span><br><span class="line">    freqs = fftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line">    <span class="keyword">return</span> freqs[:N//<span class="number">2</span>], psd[:N//<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_fft.shape, psd_fft.shape)  <span class="comment"># (500,) (500,)</span></span><br></pre></td></tr></table></figure><h3 id="2-短时傅里叶变换-STFT"><a href="#2-短时傅里叶变换-STFT" class="headerlink" title="2. 短时傅里叶变换 (STFT)"></a>2. 短时傅里叶变换 (STFT)</h3><p>STFT 适用于分析信号的时频特性。计算结果为二维时频图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_stft</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    f, t, Zxx = stft(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(Zxx) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f, t, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nperseg = <span class="number">256</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_stft.shape, times_stft.shape, psd_stft.shape)  <span class="comment"># (129,) (8,) (129, 8)</span></span><br></pre></td></tr></table></figure><h3 id="3-韦尔奇方法-Welch’s-Method"><a href="#3-韦尔奇方法-Welch’s-Method" class="headerlink" title="3. 韦尔奇方法 (Welch’s Method)"></a>3. 韦尔奇方法 (Welch’s Method)</h3><p>Welch 方法通过将信号分段并计算每段的 PSD 来提高估计的稳定性。结果为一维频谱，平滑了频谱估计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> welch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_welch</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    freqs, psd = welch(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_welch.shape, psd_welch.shape)  <span class="comment"># (129,) (129,)</span></span><br></pre></td></tr></table></figure><h3 id="4-自回归方法-AR-Method"><a href="#4-自回归方法-AR-Method" class="headerlink" title="4. 自回归方法 (AR Method)"></a>4. 自回归方法 (AR Method)</h3><p>自回归方法使用统计模型来估计信号的功率谱密度。结果为一维频谱，适用于平稳信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spectrum <span class="keyword">import</span> aryule, pburg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_ar</span>(<span class="params">signal, order, fs, method=<span class="string">&#x27;yule&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&#x27;yule&#x27;</span>:</span><br><span class="line">        ar, variance, _ = aryule(signal, order)</span><br><span class="line">        freqs, psd = pburg(signal, order, NFFT=<span class="built_in">len</span>(signal), sampling=fs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported method&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">order = <span class="number">15</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_ar.shape, psd_ar.shape)  <span class="comment"># (1000,) (1000,)</span></span><br></pre></td></tr></table></figure><h3 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h3><ul><li><strong>FFT</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>STFT</strong>: 输出为二维数组，形状为 (F, T)，表示频率和时间上的 PSD。</li><li><strong>Welch</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>AR</strong>: 输出为一维数组，形状为 (N, )，表示频率和对应的 PSD。</li></ul><h3 id="示例代码完整性"><a href="#示例代码完整性" class="headerlink" title="示例代码完整性"></a>示例代码完整性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FFT</span></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;FFT:&quot;</span>, freqs_fft.shape, psd_fft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># STFT</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;STFT:&quot;</span>, freqs_stft.shape, times_stft.shape, psd_stft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Welch</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welch:&quot;</span>, freqs_welch.shape, psd_welch.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AR</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AR:&quot;</span>, freqs_ar.shape, psd_ar.shape)</span><br></pre></td></tr></table></figure><p>每种方法都有其特定的应用场景和优缺点，选择合适的方法取决于具体的信号特性和分析需求。</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>除了短时傅里叶变换 (STFT) 以外，还有几种方法可以用来分析信号在频率和时间上的功率谱密度 (PSD)。以下是几种常见的方法：</p><h3 id="1-小波变换-Wavelet-Transform"><a href="#1-小波变换-Wavelet-Transform" class="headerlink" title="1. 小波变换 (Wavelet Transform)"></a>1. 小波变换 (Wavelet Transform)</h3><p>小波变换是另一种时频分析方法，适用于分析非平稳信号。它通过使用不同尺度的小波函数对信号进行分解，从而得到信号在不同时间和频率上的局部特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wavelet</span>(<span class="params">signal, fs, wavelet=<span class="string">&#x27;cmor&#x27;</span></span>):</span><br><span class="line">    scales = np.arange(<span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">    coefficients, frequencies = pywt.cwt(signal, scales, wavelet, sampling_period=<span class="number">1</span>/fs)</span><br><span class="line">    power_spectrum = (np.<span class="built_in">abs</span>(coefficients) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">frequencies_wavelet, power_spectrum_wavelet = calculate_psd_wavelet(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.imshow(power_spectrum_wavelet, extent=[<span class="number">0</span>, T, frequencies_wavelet[-<span class="number">1</span>], frequencies_wavelet[<span class="number">0</span>]], aspect=<span class="string">&#x27;auto&#x27;</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wavelet Transform)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT"><a href="#2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT" class="headerlink" title="2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)"></a>2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)</h3><p>希尔伯特黄变换适用于处理非线性和非平稳信号。它主要由经验模态分解 (EMD) 和希尔伯特谱分析组成。EMD 将信号分解为若干本征模态函数 (IMFs)，然后对每个 IMF 进行希尔伯特变换得到瞬时频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PyEMD <span class="keyword">import</span> EMD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_hht</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    emd = EMD()</span><br><span class="line">    imfs = emd(signal)</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    power_spectrum = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> imf <span class="keyword">in</span> imfs:</span><br><span class="line">        analytic_signal = hilbert(imf)</span><br><span class="line">        amplitude_envelope = np.<span class="built_in">abs</span>(analytic_signal)</span><br><span class="line">        instantaneous_frequency = np.unwrap(np.angle(analytic_signal)) / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        power_spectrum.append(amplitude_envelope ** <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> t, instantaneous_frequency, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_hht, frequencies_hht, power_spectrum_hht = calculate_psd_hht(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_hht, frequencies_hht, np.array(power_spectrum_hht).T, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Hilbert-Huang Transform)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD"><a href="#3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD" class="headerlink" title="3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)"></a>3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)</h3><p>Wigner-Ville 分布是一种用于信号时频分析的工具，适用于线性和非线性信号。它提供了高时间和频率分辨率，但可能会受到交叉项干扰的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tftb.processing <span class="keyword">import</span> WignerVilleDistribution</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wvd</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    wvd = WignerVilleDistribution(signal)</span><br><span class="line">    tfr, times, frequencies = wvd.run()</span><br><span class="line">    power_spectrum = np.<span class="built_in">abs</span>(tfr)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> times, frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_wvd, frequencies_wvd, power_spectrum_wvd = calculate_psd_wvd(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_wvd, frequencies_wvd, power_spectrum_wvd, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wigner-Ville Distribution)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>小波变换 (Wavelet Transform)</strong>: 提供信号在时间和频率上的局部特性，适用于非平稳信号。</li><li><strong>希尔伯特黄变换 (Hilbert-Huang Transform)</strong>: 适用于非线性和非平稳信号，通过 EMD 和希尔伯特谱分析得到瞬时频率。</li><li><strong>Wigner-Ville 分布 (Wigner-Ville Distribution)</strong>: 提供高时间和频率分辨率，适用于线性和非线性信号，但可能会受到交叉项干扰。</li></ul><p>这些方法各有优缺点，选择哪种方法取决于信号的特性和具体的分析需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Q1&quot;&gt;&lt;a href=&quot;#Q1&quot; class=&quot;headerlink&quot; title=&quot;Q1&quot;&gt;&lt;/a&gt;Q1&lt;/h2&gt;&lt;p&gt;计算功率谱密度（Power Spectral Density, PSD）的常见算法有以下几种，每种算法的计算结果略有不同，适用于不同的场景。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Use Google like a pro</title>
    <link href="http://example.com/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2024-06-05T02:56:58.592Z</published>
    <updated>2024-06-11T16:48:29.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Use-Google-like-a-pro"><a href="#Use-Google-like-a-pro" class="headerlink" title="Use Google like a pro"></a>Use Google like a pro</h1><p>原文地址：Use Google like a pro</p><p>原文作者：Marko Denic</p><p>译者：Gopal</p><h3 id="1-使用引号强制进行精确匹配搜索"><a href="#1-使用引号强制进行精确匹配搜索" class="headerlink" title="1. 使用引号强制进行精确匹配搜索"></a><strong>1. 使用引号强制进行精确匹配搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“what is javascript&quot;</span><br></pre></td></tr></table></figure><h3 id="2-And-运算符"><a href="#2-And-运算符" class="headerlink" title="2. And 运算符"></a><strong>2. And 运算符</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html AND css</span><br></pre></td></tr></table></figure><h3 id="3-使用-OR-操作符获取搜索词中某一个的结果"><a href="#3-使用-OR-操作符获取搜索词中某一个的结果" class="headerlink" title="3.  使用 OR 操作符获取搜索词中某一个的结果"></a><strong>3.  使用 OR 操作符获取搜索词中某一个的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(javascript OR python) free course</span><br></pre></td></tr></table></figure><h3 id="4-操作符将排除包含搜索词的结果"><a href="#4-操作符将排除包含搜索词的结果" class="headerlink" title="4. - 操作符将排除包含搜索词的结果"></a><strong>4. - 操作符将排除包含搜索词的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript -css</span><br></pre></td></tr></table></figure><h3 id="5-可以使用-通配符作为占位符，它将被任何单词或短语替换"><a href="#5-可以使用-通配符作为占位符，它将被任何单词或短语替换" class="headerlink" title="5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换"></a><strong>5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;how to start * in 6 months&quot;</span><br></pre></td></tr></table></figure><h3 id="6-在一个单一的网站搜索"><a href="#6-在一个单一的网站搜索" class="headerlink" title="6. 在一个单一的网站搜索"></a><strong>6. 在一个单一的网站搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:freecodecamp.org</span><br></pre></td></tr></table></figure><h3 id="7-查找特定的文件类型"><a href="#7-查找特定的文件类型" class="headerlink" title="7.  查找特定的文件类型"></a><strong>7.  查找特定的文件类型</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype:pdf learn css</span><br></pre></td></tr></table></figure><h3 id="8-搜索一个数字范围"><a href="#8-搜索一个数字范围" class="headerlink" title="8. 搜索一个数字范围"></a><strong>8. 搜索一个数字范围</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecmascript 2016..2018</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Use-Google-like-a-pro&quot;&gt;&lt;a href=&quot;#Use-Google-like-a-pro&quot; class=&quot;headerlink&quot; title=&quot;Use Google like a pro&quot;&gt;&lt;/a&gt;Use Google like a pro&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>欧拉公式与初等群论</title>
    <link href="http://example.com/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/"/>
    <id>http://example.com/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/</id>
    <published>2024-06-04T05:39:34.307Z</published>
    <updated>2024-06-12T06:00:18.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欧拉公式与初等群论"><a href="#欧拉公式与初等群论" class="headerlink" title="欧拉公式与初等群论"></a>欧拉公式与初等群论</h1><p>来源：<a href="https://www.bilibili.com/video/BV1fx41187tZ/">https://www.bilibili.com/video/BV1fx41187tZ/</a></p><h2 id="群论就是研究对称性本质的一个领域"><a href="#群论就是研究对称性本质的一个领域" class="headerlink" title="群论就是研究对称性本质的一个领域"></a>群论就是研究对称性本质的一个领域</h2><p>“群”是“对称群”的简称</p><p>加法群（一维）：平移</p><p>乘法群（一维）：缩放</p><p>复数加法群（二维）：平移+垂直方向平移</p><p>复数乘法群（二维）：缩放+旋转</p><h2 id="群就是某个数学对象上对称作用的集合"><a href="#群就是某个数学对象上对称作用的集合" class="headerlink" title="群就是某个数学对象上对称作用的集合"></a>群就是某个数学对象上对称作用的集合</h2><p>对于指数函数的性质</p><p>2^(x+y)=2^x*2^y</p><p>把指数函数的输入看作加法群的滑动作用，输出看作乘法群的缩放+旋转</p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;欧拉公式与初等群论&quot;&gt;&lt;a href=&quot;#欧拉公式与初等群论&quot; class=&quot;headerlink&quot; title=&quot;欧拉公式与初等群论&quot;&gt;&lt;/a&gt;欧拉公式与初等群论&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://www.bilibili.com/video</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/04/22/hello-world/"/>
    <id>http://example.com/2024/04/22/hello-world/</id>
    <published>2024-04-22T06:54:21.035Z</published>
    <updated>2024-04-22T06:54:21.036Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
