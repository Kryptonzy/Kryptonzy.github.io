<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-12T05:28:38.569Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STFT</title>
    <link href="http://example.com/2024/06/12/STFT/"/>
    <id>http://example.com/2024/06/12/STFT/</id>
    <published>2024-06-12T03:15:51.027Z</published>
    <updated>2024-06-12T05:28:38.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STFT介绍"><a href="#STFT介绍" class="headerlink" title="STFT介绍"></a>STFT介绍</h1><p>短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它通过在时间轴上应用移动窗口来分析信号的频率内容随时间的变化。STFT 是时频分析的基本工具之一，特别适用于分析非平稳信号（即频率成分随时间变化的信号）。</p><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><h4 id="连续时间信号的STFT"><a href="#连续时间信号的STFT" class="headerlink" title="连续时间信号的STFT"></a>连续时间信号的STFT</h4><p>设 $ x(t) $ 是一个连续时间信号，$ w(t) $ 是一个移动窗口函数（通常是一个短时窗，如汉宁窗或高斯窗）。STFT 的定义为：</p>\text{STFT}_x(t, \omega) = \int_{-\infty}^{\infty} x(\tau) w(\tau - t) e^{-j \omega \tau} \, d\tau<p>其中：</p><ul><li>$ \text{STFT}_x(t, \omega)$是在时间 $ t $ 和频率 $ \omega $ 上的短时傅里叶变换。</li><li>$ x(\tau) $ 是原始信号。</li><li>$ w(\tau - t) $ 是移动窗口函数，中心位于 $ t $。</li><li>$ e^{-j \omega \tau} $ 是傅里叶变换的核函数。</li></ul><p>STFT 将信号在每个时间点 $ t $ 上截取一个窗函数 $ w(t) $，并对窗口内的信号进行傅里叶变换。通过移动窗函数的位置，可以得到不同时间点上的频谱，从而得到信号的时频表示。</p><h4 id="离散时间信号的STFT"><a href="#离散时间信号的STFT" class="headerlink" title="离散时间信号的STFT"></a>离散时间信号的STFT</h4><p>对于离散时间信号 $ x[n] $，其STFT定义为：</p>\text{STFT}_x(m, \omega) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \omega n}<p>其中：</p><ul><li>$ x[n] $ 是离散时间信号。</li><li>$ w[n - m] $ 是移动窗口函数，中心位于 $ m $。</li><li>$ e^{-j \omega n} $ 是傅里叶变换的核函数。</li></ul><p>通常，离散时间STFT的频率参数 $ \omega $ 被离散化为 $ \omega = \frac{2\pi k}{N} $（其中 $ N $ 是FFT的长度），因此离散STFT可以表示为：</p>\text{STFT}_x(m, k) = \sum_{n=-\infty}^{\infty} x[n] w[n - m] e^{-j \frac{2\pi k}{N} n}<h3 id="STFT的步骤"><a href="#STFT的步骤" class="headerlink" title="STFT的步骤"></a>STFT的步骤</h3><ol><li><p><strong>窗口化</strong>：</p><ul><li>使用一个窗函数（如汉宁窗、高斯窗等）截取信号的一部分。窗口函数通常是一个短时窗，长度较短，可以移动。</li></ul></li><li><p><strong>移动窗口</strong>：</p><ul><li>将窗口函数在信号上移动，每次移动一个步长（通常称为 hop size），截取信号的不同部分。</li></ul></li><li><p><strong>傅里叶变换</strong>：</p><ul><li>对每个窗口内的信号进行傅里叶变换，计算出窗口内信号的频谱。</li></ul></li><li><p><strong>组合结果</strong>：</p><ul><li>将每个时间窗口的频谱组合在一起，形成信号的时频表示。</li></ul></li></ol><h3 id="STFT-的特性"><a href="#STFT-的特性" class="headerlink" title="STFT 的特性"></a>STFT 的特性</h3><ul><li><p><strong>时间和频率分辨率的权衡</strong>：</p><ul><li>窗口的长度决定了时间和频率分辨率之间的权衡。较短的窗口提供较高的时间分辨率，但频率分辨率较低；较长的窗口提供较高的频率分辨率，但时间分辨率较低。</li></ul></li><li><p><strong>非平稳信号的分析</strong>：</p><ul><li>STFT 特别适用于分析非平稳信号，可以捕捉信号频率成分随时间的变化。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用STFT进行时频分析的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例信号</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)  <span class="comment"># 时间向量</span></span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算STFT</span></span><br><span class="line">f, t, Zxx = stft(signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制STFT结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.pcolormesh(t, f, np.<span class="built_in">abs</span>(Zxx), shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;STFT Magnitude&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Magnitude&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>STFT 是一种通过在时间轴上应用移动窗口来分析信号频率内容随时间变化的方法。通过选择不同的窗口长度和步长，可以在时间和频率分辨率之间进行权衡，适用于分析非平稳信号。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STFT介绍&quot;&gt;&lt;a href=&quot;#STFT介绍&quot; class=&quot;headerlink&quot; title=&quot;STFT介绍&quot;&gt;&lt;/a&gt;STFT介绍&lt;/h1&gt;&lt;p&gt;短时傅里叶变换（Short-Time Fourier Transform, STFT）是傅里叶变换的一种，它</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/"/>
    <id>http://example.com/2024/06/12/%E7%9E%AC%E6%97%B6%E9%A2%91%E7%8E%87/</id>
    <published>2024-06-11T16:37:38.887Z</published>
    <updated>2024-06-12T03:55:16.628Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="瞬时频率"><a href="#瞬时频率" class="headerlink" title="瞬时频率"></a>瞬时频率</h2><h1 id="两种计算瞬时频率的方法"><a href="#两种计算瞬时频率的方法" class="headerlink" title="两种计算瞬时频率的方法"></a>两种计算瞬时频率的方法</h1><p>这两种方法在计算瞬时频率时有不同的原理和应用场景：</p><h3 id="Hilbert-变换方法"><a href="#Hilbert-变换方法" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Hilbert 变换方法通过计算信号的解析信号（analytic signal），并从中获取相位信息。然后，通过对相位进行微分得到瞬时频率。其数学表达式为：</p>f_{\text{inst}}(t) = \frac{1}{2\pi} \frac{d\phi}{dt}<p>其中，$\phi$ 是解析信号的相位。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>直接且快速，适用于单分量信号（即信号的频率在任一时刻是单一的）。</li><li>对于噪声相对不敏感。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>对于多分量信号（即信号在同一时刻含有多个频率成分）效果较差，因为无法区分不同的频率成分。</li><li>对非平稳信号的瞬时频率变化可能不够准确。</li></ul></li></ol><h3 id="条件频谱矩方法（TFMoment）"><a href="#条件频谱矩方法（TFMoment）" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>条件频谱矩方法基于时间-频率分布（如谱图）的功率谱来计算瞬时频率。它计算在每个时刻的频谱重心，公式如下：</p>f_{\text{inst}}(t) = \frac{\int_0^\infty f P(t, f) \, df}{\int_0^\infty P(t, f) \, df}<p>其中，$P(t, f)$ 是时间 $t$ 和频率 $f$ 下的功率谱。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li><p><strong>优点</strong>：</p><ul><li>适用于多分量信号，能够区分和处理多个频率成分。</li><li>能够更准确地捕捉非平稳信号的瞬时频率变化。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>计算复杂度较高，需要计算时间-频率分布（如谱图）。</li><li>对于噪声敏感，可能需要对信号进行预处理以减少噪声的影响。</li></ul></li></ol><h3 id="如何选择方法"><a href="#如何选择方法" class="headerlink" title="如何选择方法"></a>如何选择方法</h3><ul><li><strong>单分量信号</strong>：如果您的信号在任一时刻只包含一个主要频率成分，并且信号相对平稳，Hilbert 变换方法可能更简单高效。</li><li><strong>多分量信号或非平稳信号</strong>：如果您的信号包含多个频率成分或是非平稳信号，条件频谱矩方法（TFMoment）更适合，因为它能够更准确地捕捉复杂信号的频率变化。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>这里是两个方法的实现示例，您可以根据您的具体需求选择合适的方法。</p><h4 id="Hilbert-变换方法-1"><a href="#Hilbert-变换方法-1" class="headerlink" title="Hilbert 变换方法"></a>Hilbert 变换方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> hilbert</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_hilbert</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t = np.arange(n_samples - <span class="number">1</span>) / fs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        analytic_signal = hilbert(signal[channel])</span><br><span class="line">        instantaneous_phase = np.unwrap(np.angle(analytic_signal))</span><br><span class="line">        instantaneous_frequency = np.diff(instantaneous_phase) * fs / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        inst_freq.append(instantaneous_frequency)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_hilbert(x, fs)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (Hilbert)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="条件频谱矩方法（TFMoment）-1"><a href="#条件频谱矩方法（TFMoment）-1" class="headerlink" title="条件频谱矩方法（TFMoment）"></a>条件频谱矩方法（TFMoment）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> spectrogram</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_instantaneous_frequency_tfmoment</span>(<span class="params">signal, fs, nperseg=<span class="number">256</span>, noverlap=<span class="number">128</span>, nfft=<span class="number">256</span></span>):</span><br><span class="line">    n_channels, n_samples = signal.shape</span><br><span class="line">    inst_freq = []</span><br><span class="line">    t_vals = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel <span class="keyword">in</span> <span class="built_in">range</span>(n_channels):</span><br><span class="line">        f, t, Sxx = spectrogram(signal[channel], fs, nperseg=nperseg, noverlap=noverlap, nfft=nfft)</span><br><span class="line">        P_t_f = Sxx.T</span><br><span class="line">        numerator = np.<span class="built_in">sum</span>(f * P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        denominator = np.<span class="built_in">sum</span>(P_t_f, axis=<span class="number">1</span>)</span><br><span class="line">        inst_freq_channel = numerator / denominator</span><br><span class="line">        inst_freq.append(inst_freq_channel)</span><br><span class="line">        t_vals.append(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(inst_freq), np.array(t_vals[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例信号</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">x = np.expand_dims(signal, axis=<span class="number">0</span>)</span><br><span class="line">nperseg = <span class="number">128</span></span><br><span class="line">noverlap = <span class="number">64</span></span><br><span class="line">nfft = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">instantaneous_frequency, time_points = compute_instantaneous_frequency_tfmoment(x, fs, nperseg, noverlap, nfft)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(t, signal)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Signal&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Amplitude&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(time_points, instantaneous_frequency[<span class="number">0</span>, :])</span><br><span class="line">plt.title(<span class="string">&#x27;Instantaneous Frequency (TFMoment)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [s]&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过运行这些代码示例，您可以直观地看到不同方法的计算结果，并选择最适合您的应用场景的方法。如果您有进一步的需求或问题，请告诉我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;瞬时频率&quot;&gt;&lt;a href=&quot;#瞬时频率&quot; class=&quot;headerlink&quot; title=&quot;瞬时频率&quot;&gt;&lt;/a&gt;瞬时频率&lt;/h2&gt;&lt;h1 id=&quot;两种计算瞬时频率的方法&quot;&gt;&lt;a href=&quot;#两种计算瞬时频率的方法&quot; class=&quot;headerlin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD./"/>
    <id>http://example.com/2024/06/11/%E7%A6%BB%E6%95%A3%E8%BF%98%E6%98%AF%E8%BF%9E%E7%BB%AD./</id>
    <published>2024-06-11T10:31:53.169Z</published>
    <updated>2024-06-12T03:55:56.656Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="世界是连续的还是离散的"><a href="#世界是连续的还是离散的" class="headerlink" title="世界是连续的还是离散的"></a>世界是连续的还是离散的</h2><h1 id="世界是连续的还是离散的-1"><a href="#世界是连续的还是离散的-1" class="headerlink" title="世界是连续的还是离散的"></a>世界是连续的还是离散的</h1><p>“世界是连续的还是离散的”这一问题可以从不同的学科视角进行讨论，如物理学、哲学和计算机科学。每个领域的观点都可能有所不同。</p><h3 id="物理学视角"><a href="#物理学视角" class="headerlink" title="物理学视角"></a>物理学视角</h3><ol><li><strong>经典物理学</strong> ：</li></ol><ul><li>经典物理学（如牛顿力学、电磁学等）通常认为世界是连续的。例如，时间和空间被认为是连续的，物体可以在任何时间点和空间位置上运动。</li></ul><ol><li><strong>量子力学</strong> ：</li></ol><ul><li>量子力学提供了一种截然不同的观点。在微观尺度下，某些物理量是量子化的，即只能取离散的值。例如，电子的能级、光子的能量等都是离散的。这表明，在某些情况下，世界是离散的。</li><li>但量子力学中的波函数是连续的，它描述了粒子在空间中的概率分布。因此，量子力学同时包含连续和离散的特性。</li></ul><ol><li><strong>时空量子化</strong> ：</li></ol><ul><li>有些理论物理学家提出了时空量子化的概念，认为在极小尺度（如普朗克尺度）上，时空可能是离散的。这是一种仍在研究中的假设，尚未得到实验验证。</li></ul><h3 id="哲学视角"><a href="#哲学视角" class="headerlink" title="哲学视角"></a>哲学视角</h3><ol><li><strong>实在论</strong> ：</li></ol><ul><li>认为世界的本质是独立于我们的感知和测量的。对于这种观点，世界可以是连续的，也可以是离散的，这取决于其真实的物理特性。</li></ul><ol><li><strong>唯物主义</strong> ：</li></ol><ul><li>认为物质是世界的基本组成部分。这种观点通常倾向于认为世界是连续的，因为物质和能量的流动似乎是连续的。</li></ul><ol><li><strong>主观唯心主义</strong> ：</li></ol><ul><li>认为我们的感知决定了我们对世界的理解。对于这种观点，世界的连续性或离散性是由我们的感知和测量决定的，而不是世界本身的特性。</li></ul><h3 id="计算机科学视角"><a href="#计算机科学视角" class="headerlink" title="计算机科学视角"></a>计算机科学视角</h3><ol><li><strong>数字化世界</strong> ：</li></ol><ul><li>在计算机科学中，所有信息都是离散的。计算机处理离散的二进制数据，任何连续信号（如声音、图像）都必须经过采样和量化才能被计算机处理。</li></ul><ol><li><strong>模拟信号处理</strong> ：</li></ol><ul><li>虽然计算机处理的是离散信号，但它们可以模拟连续信号。这种模拟是通过高频采样和精确的计算来实现的。</li></ul><h3 id="综合视角"><a href="#综合视角" class="headerlink" title="综合视角"></a>综合视角</h3><ol><li><strong>多尺度视角</strong> ：</li></ol><ul><li>世界的连续性和离散性可能取决于观察的尺度。在宏观尺度上（如日常生活中的物体运动），世界看起来是连续的；而在微观尺度上（如原子和电子的行为），世界表现出离散性。</li></ul><ol><li><strong>测量和工具的限制</strong> ：</li></ol><ul><li>我们对世界的理解受到测量工具和方法的限制。高精度的测量工具可以揭示更微观的细节，而这些细节可能表现出离散性。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>世界是连续的还是离散的，取决于我们观察的尺度和视角。从宏观来看，世界似乎是连续的；从微观和量子力学的角度来看，世界表现出离散性。哲学上，世界的本质可能既包含连续性也包含离散性。这一问题并没有一个简单的答案，而是取决于具体的上下文和研究领域。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;世界是连续的还是离散的&quot;&gt;&lt;a href=&quot;#世界是连续的还是离散的&quot; class=&quot;headerlink&quot; title=&quot;世界是连续的还是离散的&quot;&gt;&lt;/a&gt;世界是连续的还是离散的&lt;/h2&gt;&lt;h1 id=&quot;世界是连续的还是离散的-1&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/11/%E8%B0%B1%E7%86%B5/"/>
    <id>http://example.com/2024/06/11/%E8%B0%B1%E7%86%B5/</id>
    <published>2024-06-11T09:23:23.869Z</published>
    <updated>2024-06-11T16:49:10.199Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="谱熵"><a href="#谱熵" class="headerlink" title="谱熵"></a>谱熵</h2><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>计算功率谱密度（Power Spectral Density, PSD）的常见算法有以下几种，每种算法的计算结果略有不同，适用于不同的场景。下面介绍几种常见的计算 PSD 的算法，并解释它们的输出形状。</p><h3 id="1-快速傅里叶变换-FFT"><a href="#1-快速傅里叶变换-FFT" class="headerlink" title="1. 快速傅里叶变换 (FFT)"></a>1. 快速傅里叶变换 (FFT)</h3><p>FFT 是最常用的一种方法，适用于分析信号的整体频率特性。计算结果为一维频谱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.fft <span class="keyword">import</span> fft, fftfreq</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_fft</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(signal)</span><br><span class="line">    fft_values = fft(signal)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(fft_values) ** <span class="number">2</span> / N</span><br><span class="line">    freqs = fftfreq(N, <span class="number">1</span>/fs)</span><br><span class="line">    <span class="keyword">return</span> freqs[:N//<span class="number">2</span>], psd[:N//<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span></span><br><span class="line">T = <span class="number">1</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)</span><br><span class="line"></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_fft.shape, psd_fft.shape)  <span class="comment"># (500,) (500,)</span></span><br></pre></td></tr></table></figure><h3 id="2-短时傅里叶变换-STFT"><a href="#2-短时傅里叶变换-STFT" class="headerlink" title="2. 短时傅里叶变换 (STFT)"></a>2. 短时傅里叶变换 (STFT)</h3><p>STFT 适用于分析信号的时频特性。计算结果为二维时频图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> stft</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_stft</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    f, t, Zxx = stft(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    psd = np.<span class="built_in">abs</span>(Zxx) ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> f, t, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nperseg = <span class="number">256</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_stft.shape, times_stft.shape, psd_stft.shape)  <span class="comment"># (129,) (8,) (129, 8)</span></span><br></pre></td></tr></table></figure><h3 id="3-韦尔奇方法-Welch’s-Method"><a href="#3-韦尔奇方法-Welch’s-Method" class="headerlink" title="3. 韦尔奇方法 (Welch’s Method)"></a>3. 韦尔奇方法 (Welch’s Method)</h3><p>Welch 方法通过将信号分段并计算每段的 PSD 来提高估计的稳定性。结果为一维频谱，平滑了频谱估计。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.signal <span class="keyword">import</span> welch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_welch</span>(<span class="params">signal, fs, nperseg</span>):</span><br><span class="line">    freqs, psd = welch(signal, fs=fs, nperseg=nperseg)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(freqs_welch.shape, psd_welch.shape)  <span class="comment"># (129,) (129,)</span></span><br></pre></td></tr></table></figure><h3 id="4-自回归方法-AR-Method"><a href="#4-自回归方法-AR-Method" class="headerlink" title="4. 自回归方法 (AR Method)"></a>4. 自回归方法 (AR Method)</h3><p>自回归方法使用统计模型来估计信号的功率谱密度。结果为一维频谱，适用于平稳信号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spectrum <span class="keyword">import</span> aryule, pburg</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_ar</span>(<span class="params">signal, order, fs, method=<span class="string">&#x27;yule&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">&#x27;yule&#x27;</span>:</span><br><span class="line">        ar, variance, _ = aryule(signal, order)</span><br><span class="line">        freqs, psd = pburg(signal, order, NFFT=<span class="built_in">len</span>(signal), sampling=fs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Unsupported method&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> freqs, psd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">order = <span class="number">15</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(freqs_ar.shape, psd_ar.shape)  <span class="comment"># (1000,) (1000,)</span></span><br></pre></td></tr></table></figure><h3 id="结果总结"><a href="#结果总结" class="headerlink" title="结果总结"></a>结果总结</h3><ul><li><strong>FFT</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>STFT</strong>: 输出为二维数组，形状为 (F, T)，表示频率和时间上的 PSD。</li><li><strong>Welch</strong>: 输出为一维数组，形状为 (N/2, )，表示频率和对应的 PSD。</li><li><strong>AR</strong>: 输出为一维数组，形状为 (N, )，表示频率和对应的 PSD。</li></ul><h3 id="示例代码完整性"><a href="#示例代码完整性" class="headerlink" title="示例代码完整性"></a>示例代码完整性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FFT</span></span><br><span class="line">freqs_fft, psd_fft = calculate_psd_fft(signal, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;FFT:&quot;</span>, freqs_fft.shape, psd_fft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># STFT</span></span><br><span class="line">freqs_stft, times_stft, psd_stft = calculate_psd_stft(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;STFT:&quot;</span>, freqs_stft.shape, times_stft.shape, psd_stft.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Welch</span></span><br><span class="line">freqs_welch, psd_welch = calculate_psd_welch(signal, fs, nperseg)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welch:&quot;</span>, freqs_welch.shape, psd_welch.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># AR</span></span><br><span class="line">freqs_ar, psd_ar = calculate_psd_ar(signal, order, fs)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AR:&quot;</span>, freqs_ar.shape, psd_ar.shape)</span><br></pre></td></tr></table></figure><p>每种方法都有其特定的应用场景和优缺点，选择合适的方法取决于具体的信号特性和分析需求。</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>除了短时傅里叶变换 (STFT) 以外，还有几种方法可以用来分析信号在频率和时间上的功率谱密度 (PSD)。以下是几种常见的方法：</p><h3 id="1-小波变换-Wavelet-Transform"><a href="#1-小波变换-Wavelet-Transform" class="headerlink" title="1. 小波变换 (Wavelet Transform)"></a>1. 小波变换 (Wavelet Transform)</h3><p>小波变换是另一种时频分析方法，适用于分析非平稳信号。它通过使用不同尺度的小波函数对信号进行分解，从而得到信号在不同时间和频率上的局部特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wavelet</span>(<span class="params">signal, fs, wavelet=<span class="string">&#x27;cmor&#x27;</span></span>):</span><br><span class="line">    scales = np.arange(<span class="number">1</span>, <span class="number">128</span>)</span><br><span class="line">    coefficients, frequencies = pywt.cwt(signal, scales, wavelet, sampling_period=<span class="number">1</span>/fs)</span><br><span class="line">    power_spectrum = (np.<span class="built_in">abs</span>(coefficients) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">frequencies_wavelet, power_spectrum_wavelet = calculate_psd_wavelet(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.imshow(power_spectrum_wavelet, extent=[<span class="number">0</span>, T, frequencies_wavelet[-<span class="number">1</span>], frequencies_wavelet[<span class="number">0</span>]], aspect=<span class="string">&#x27;auto&#x27;</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wavelet Transform)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT"><a href="#2-希尔伯特黄变换-Hilbert-Huang-Transform-HHT" class="headerlink" title="2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)"></a>2. 希尔伯特黄变换 (Hilbert-Huang Transform, HHT)</h3><p>希尔伯特黄变换适用于处理非线性和非平稳信号。它主要由经验模态分解 (EMD) 和希尔伯特谱分析组成。EMD 将信号分解为若干本征模态函数 (IMFs)，然后对每个 IMF 进行希尔伯特变换得到瞬时频率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PyEMD <span class="keyword">import</span> EMD</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_hht</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    emd = EMD()</span><br><span class="line">    imfs = emd(signal)</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    power_spectrum = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> imf <span class="keyword">in</span> imfs:</span><br><span class="line">        analytic_signal = hilbert(imf)</span><br><span class="line">        amplitude_envelope = np.<span class="built_in">abs</span>(analytic_signal)</span><br><span class="line">        instantaneous_frequency = np.unwrap(np.angle(analytic_signal)) / (<span class="number">2.0</span> * np.pi)</span><br><span class="line">        power_spectrum.append(amplitude_envelope ** <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> t, instantaneous_frequency, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_hht, frequencies_hht, power_spectrum_hht = calculate_psd_hht(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_hht, frequencies_hht, np.array(power_spectrum_hht).T, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Hilbert-Huang Transform)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD"><a href="#3-Wigner-Ville-分布-Wigner-Ville-Distribution-WVD" class="headerlink" title="3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)"></a>3. Wigner-Ville 分布 (Wigner-Ville Distribution, WVD)</h3><p>Wigner-Ville 分布是一种用于信号时频分析的工具，适用于线性和非线性信号。它提供了高时间和频率分辨率，但可能会受到交叉项干扰的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tftb.processing <span class="keyword">import</span> WignerVilleDistribution</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_psd_wvd</span>(<span class="params">signal, fs</span>):</span><br><span class="line">    t = np.arange(<span class="built_in">len</span>(signal)) / fs</span><br><span class="line">    wvd = WignerVilleDistribution(signal)</span><br><span class="line">    tfr, times, frequencies = wvd.run()</span><br><span class="line">    power_spectrum = np.<span class="built_in">abs</span>(tfr)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> times, frequencies, power_spectrum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fs = <span class="number">1000</span>  <span class="comment"># 采样频率</span></span><br><span class="line">T = <span class="number">1</span>  <span class="comment"># 信号持续时间</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, T, fs * T, endpoint=<span class="literal">False</span>)</span><br><span class="line">signal = np.sin(<span class="number">2</span> * np.pi * <span class="number">50</span> * t) + <span class="number">0.5</span> * np.sin(<span class="number">2</span> * np.pi * <span class="number">120</span> * t)  <span class="comment"># 生成一个示例信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算功率谱</span></span><br><span class="line">times_wvd, frequencies_wvd, power_spectrum_wvd = calculate_psd_wvd(signal, fs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制功率谱</span></span><br><span class="line">plt.pcolormesh(times_wvd, frequencies_wvd, power_spectrum_wvd, shading=<span class="string">&#x27;gouraud&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency [Hz]&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Time [sec]&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Power Spectrum Density (Wigner-Ville Distribution)&#x27;</span>)</span><br><span class="line">plt.colorbar(label=<span class="string">&#x27;Power&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>小波变换 (Wavelet Transform)</strong>: 提供信号在时间和频率上的局部特性，适用于非平稳信号。</li><li><strong>希尔伯特黄变换 (Hilbert-Huang Transform)</strong>: 适用于非线性和非平稳信号，通过 EMD 和希尔伯特谱分析得到瞬时频率。</li><li><strong>Wigner-Ville 分布 (Wigner-Ville Distribution)</strong>: 提供高时间和频率分辨率，适用于线性和非线性信号，但可能会受到交叉项干扰。</li></ul><p>这些方法各有优缺点，选择哪种方法取决于信号的特性和具体的分析需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;谱熵&quot;&gt;&lt;a href=&quot;#谱熵&quot; class=&quot;headerlink&quot; title=&quot;谱熵&quot;&gt;&lt;/a&gt;谱熵&lt;/h2&gt;&lt;h2 id=&quot;Q1&quot;&gt;&lt;a href=&quot;#Q1&quot; class=&quot;headerlink&quot; title=&quot;Q1&quot;&gt;&lt;/a&gt;Q1&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Use Google like a pro</title>
    <link href="http://example.com/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2024/06/05/google%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2024-06-05T02:56:58.592Z</published>
    <updated>2024-06-11T16:48:29.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Use-Google-like-a-pro"><a href="#Use-Google-like-a-pro" class="headerlink" title="Use Google like a pro"></a>Use Google like a pro</h1><p>原文地址：Use Google like a pro</p><p>原文作者：Marko Denic</p><p>译者：Gopal</p><h3 id="1-使用引号强制进行精确匹配搜索"><a href="#1-使用引号强制进行精确匹配搜索" class="headerlink" title="1. 使用引号强制进行精确匹配搜索"></a><strong>1. 使用引号强制进行精确匹配搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“what is javascript&quot;</span><br></pre></td></tr></table></figure><h3 id="2-And-运算符"><a href="#2-And-运算符" class="headerlink" title="2. And 运算符"></a><strong>2. And 运算符</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html AND css</span><br></pre></td></tr></table></figure><h3 id="3-使用-OR-操作符获取搜索词中某一个的结果"><a href="#3-使用-OR-操作符获取搜索词中某一个的结果" class="headerlink" title="3.  使用 OR 操作符获取搜索词中某一个的结果"></a><strong>3.  使用 OR 操作符获取搜索词中某一个的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(javascript OR python) free course</span><br></pre></td></tr></table></figure><h3 id="4-操作符将排除包含搜索词的结果"><a href="#4-操作符将排除包含搜索词的结果" class="headerlink" title="4. - 操作符将排除包含搜索词的结果"></a><strong>4. - 操作符将排除包含搜索词的结果</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript -css</span><br></pre></td></tr></table></figure><h3 id="5-可以使用-通配符作为占位符，它将被任何单词或短语替换"><a href="#5-可以使用-通配符作为占位符，它将被任何单词或短语替换" class="headerlink" title="5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换"></a><strong>5. 可以使用 (*) 通配符作为占位符，它将被任何单词或短语替换</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;how to start * in 6 months&quot;</span><br></pre></td></tr></table></figure><h3 id="6-在一个单一的网站搜索"><a href="#6-在一个单一的网站搜索" class="headerlink" title="6. 在一个单一的网站搜索"></a><strong>6. 在一个单一的网站搜索</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:freecodecamp.org</span><br></pre></td></tr></table></figure><h3 id="7-查找特定的文件类型"><a href="#7-查找特定的文件类型" class="headerlink" title="7.  查找特定的文件类型"></a><strong>7.  查找特定的文件类型</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filetype:pdf learn css</span><br></pre></td></tr></table></figure><h3 id="8-搜索一个数字范围"><a href="#8-搜索一个数字范围" class="headerlink" title="8. 搜索一个数字范围"></a><strong>8. 搜索一个数字范围</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecmascript 2016..2018</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Use-Google-like-a-pro&quot;&gt;&lt;a href=&quot;#Use-Google-like-a-pro&quot; class=&quot;headerlink&quot; title=&quot;Use Google like a pro&quot;&gt;&lt;/a&gt;Use Google like a pro&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/"/>
    <id>http://example.com/2024/06/04/%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F%E4%B8%8E%E5%88%9D%E7%AD%89%E7%BE%A4%E8%AE%BA/</id>
    <published>2024-06-04T05:39:34.307Z</published>
    <updated>2024-06-12T03:55:45.711Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="欧拉公式与初等群论"><a href="#欧拉公式与初等群论" class="headerlink" title="欧拉公式与初等群论"></a>欧拉公式与初等群论</h2><h1 id="欧拉公式与初等群论-1"><a href="#欧拉公式与初等群论-1" class="headerlink" title="欧拉公式与初等群论"></a>欧拉公式与初等群论</h1><p>来源：<a href="https://www.bilibili.com/video/BV1fx41187tZ/">https://www.bilibili.com/video/BV1fx41187tZ/</a></p><h2 id="群论就是研究对称性本质的一个领域"><a href="#群论就是研究对称性本质的一个领域" class="headerlink" title="群论就是研究对称性本质的一个领域"></a>群论就是研究对称性本质的一个领域</h2><p>“群”是“对称群”的简称</p><p>加法群（一维）：平移</p><p>乘法群（一维）：缩放</p><p>复数加法群（二维）：平移+垂直方向平移</p><p>复数乘法群（二维）：缩放+旋转</p><h2 id="群就是某个数学对象上对称作用的集合"><a href="#群就是某个数学对象上对称作用的集合" class="headerlink" title="群就是某个数学对象上对称作用的集合"></a>群就是某个数学对象上对称作用的集合</h2><p>对于指数函数的性质</p><p>2^(x+y)=2^x*2^y</p><p>把指数函数的输入看作加法群的滑动作用，输出看作乘法群的缩放+旋转</p><h2 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;欧拉公式与初等群论&quot;&gt;&lt;a href=&quot;#欧拉公式与初等群论&quot; class=&quot;headerlink&quot; title=&quot;欧拉公式与初等群论&quot;&gt;&lt;/a&gt;欧拉公式与初等群论&lt;/h2&gt;&lt;h1 id=&quot;欧拉公式与初等群论-1&quot;&gt;&lt;a href=&quot;#欧拉公式与初等群论</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/04/22/hello-world/"/>
    <id>http://example.com/2024/04/22/hello-world/</id>
    <published>2024-04-22T06:54:21.035Z</published>
    <updated>2024-04-22T06:54:21.036Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
